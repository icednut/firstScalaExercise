3장. 스칼라 두 번째 걸음
==================
콘즈 연산자 (::)
 ㄴ 콘즈 연산자의 호출 대상 객체는 콜론(:) 바로 뒤의 객체이다.

리스트 뒤에 원소를 추가하는 효율적인 방법
 ㄴ 리스트를 뒤집는다 (reverse) -> 콘즈 연산자로 맨 앞에 요소 추가 -> 다시 뒤집는다.
 ㄴ 이렇게 하는 이유: 리스트 뒤에 원소를 추가하는 연산은 리스트의 길이에 비례한 시간이 걸리기 때문, 반면 콘즈 연산자는 상수 시간이 걸린다.

튜플
 ㄴ 각기 다른 타입의 원소를 담을 수 있는 컬렉션
 ㄴ 튜플에는 동시에 문자열과 정수를 함께 넣을 수 있다.
 ㄴ 단, 튜플의 원소를 리스트의 원소와 같이 접근할 수 는 없다.
 ㄴ 반드시 ._N 으로 접근 (또 N은 0이 아니라 1부터 시작)

집합과 맵

함수형으로 한 걸음 더 나아가는 방법은 var를 사용하지 않고 프로그램하려 노력하는 것이다.
스칼라는 val을 더 많이 사용하도록 권한다.

스칼라 프로그래머의 균현 잡힌 태도
val, 변경 불가능한 객체, 부수 효과가 없는 메소드를 더 많이 사용하라. 먼저 그런 접근 방법을 먼저 시도해보라. var나 변경 가능 객체나 부수 효과가 있는 메소드를 사용해야 할 구체적인 필요성이 있고 그런 이유를 정당화할 수 있는 경우에만 var, 변경 가능성, 부수 효과를 활용하라.


4장. 클래스와 객체
==================
클래스 (class)
 ㄴ 스칼라의 기본 접근 수준은 전체 공개다.
 ㄴ 메소드 파라미터는 항상 val 이다. (재할당 시 Compile error)
 ㄴ 메소드 마지막에는 명시적으로 return을 사용하지 않아도 맨 나중에 계산한 값을 반환한다.
 ㄴ 메소드 작성 시 권한하는 스타일은 return을 명시적으로 사용하지 않는 것, 특히 여러 번 사용하지 않는 것이다. 대신 각 메소드가 한 값을 계산하는 표현식인 것 처럼 생각하라. 이렇게 계산한 값이 바로 메소드의 반환 값이다. 이런 철학을 가지고 코딩하면, 메소드를 아주 작게 유지하고 커다란 메소드를 더 작은 여러 메소드로 나누게 된다. 다만 환경에 따라 다르므로 명시적으로 return을 사용할 수 는 있다.
 ㄴ 스칼라 클래스에는 정적(static) 멤버가 없다. 대신 싱글톤 객체를 제공한다.

싱글톤 객체 (object)
 ㄴ 어떤 싱글톤 객체의 이름이 어떤 클래스와 같을 때, 그 객체를 클래스의 동반 객체(companion object)라고 한다. 다만, 클래스와 동반 객체는 반드시 같은 소스 파일 안에 정의해야 한다. 이때 역으로 해당 클래스를 싱글톤 객체의 동반 클래스(companion class)라 부른다. 클래스와 동반 객체는 상대방의 비공개 멤버에 접근할 수 있다.
 ㄴ 자바 프로그래머라면 싱글톤을 자바의 정적 메소드를 담아두는 집처럼 생각하는 것도 한 가지 방법이다. 싱글톤 객체의 메소드도 정적 메소드와 비슷한 방식으로 호출할 수 있다.
 ㄴ 싱글톤 객체 정의는 타입을 정의하지 않는다. 따라서 싱글톤 객체 정의만 있다면 해당 타입의 객체를 만들 수 없다. (싱글톤은 new로 인스턴스화 할 수 없다.) 이 때는 동반 클래스를 정의해야만 해당 타입의 객체를 만들 수 있다.
 ㄴ 클래스와 싱글톤 객체의 한 가지 차이는 싱글톤 객체는 파라미터를 받을 수 없고 클래스는 받을 수 있다는 점이다. 싱글톤은 new로 인스턴스화할 수 없기 때문에 파라미터를 싱글톤에 넘길 방법이 없다.
 ㄴ 컴파일러는 각 싱글톤 객체를 합성한 클래스(synthetic class)의 인스턴스로 구현하고, 이를 정적 변수가 참조한다.
 ㄴ 동반 클래스가 없는 싱글톤 객체를 독립 개체라고도 한다.
 ㄴ 독립 객체의 활용법은 필요한 도구 메소드를 한데 모아두거나(java의 util 클래스), 스칼라 애플리케이션의 진입점을 만들 때 사용할 수 있다.
 ㄴ 자바에서는 public class를 그 클래스 이름과 같은 이름의 파일에 저장해야 하지만, 스칼라에서는 원하는 대로 .scala로 끝나는 파일 이름을 정할 수 있다는 점이다. 그 파일 안에는 마음대로 아무 클래스나 코드를 넣을 수 있다. 하지만 스크립트가 아닌 경우 자바와 마찬가지로 파일에 들어갈 클래스 이름을 따라 파일 이름을 짓는 것을 권장한다.
 ㄴ .scala 파일 안에 정의만 들어있는 것은 스크립트가 아니다. 스크립트는 결과를 계산하는 표현식이 끝에 와야만 한다. 114쪽 참조

참고
 ㄴ 스칼라는 항상 java.lang과 scala 패키지의 멤버를 암시적으로 임포트한다. 또한 scala 패키지에 있는 Predef라는 싱글톤 객체의 멤버도 항상 임포트 한다. Predef에는 유용한 메소드가 많이 있으며, println도 실제로는 Predef의 println을 호출하는 것이다. (Predef.println은 다시 Console.println을 호출하고, 그 메소드가 실제 출력을 수행한다.) assert를 사용할 때도 역시 Predef.assert를 사용하는 것이다.
 ㄴ fsc (fast scala compiler)


5장. 기본 타입과 연산
====================
Int
 ㄴ 16진수: 0x로 시작할 경우
 ㄴ 8진수: 0 으로 시작할 경우
 ㄴ 10진수: 0이 아닌 숫자로 시작하고 그 밖의 추가 장식이 없을 경우

Long
 ㄴ 정수 리터럴이 L이나 l로 끝나면 Long
 ㄴ 끝에 아무것도 없으면 Int 이다.

Double, Float
 ㄴ 부동소수점 리터럴이 F나 f로 끝나면 그 수는 Float 타입
 ㄴ 그렇지 않는 부동소수점 리터럴은 Double

Char
 ㄴ 작은 따옴표 안에 유니코드 문자를 넣은 문자 리터럴을 지칭

심볼 리터럴

연산자
 ㄴ 리터럴 비교 뿐만 아니라 객체 및 객체 필드 값 비교까지 가능
 ㄴ 자동으로 null을 체크하기 때문에 직접 null을 검사할 필요가 없다.


6장. 함수형 객체
====================
여기서는 좀 더 완전한 기능을 갖춘 스칼라 클래스 작성법을 알아본다.
변경 가능한 상태를 전혀 갖지 않는 함수형 객체 (functional object)을 다룬다.

변경 불가 분수 클래스(Rational)을 만들어보자

class Rational(n: Int, d: Int)

클래스 이름인 Rational 뒤에 괄호가 오고, 그 안에 n과 d라는 식별자가 있다.
이를 클래스 파라미터 라고 부른다. 스칼라 컴파일러는 내부적으로 두 클래스 파라미터를 종합해서, 클래스 파라미터와 같은 두 인자를 받는 주 생성자 (primary constructor)를 만든다.


class Rational(n: Int, d: Int) {
     println(“Created “ + n + “/“ + d)
}

스칼라 컴파일러는 println을 호출하는 위 코드를 Rational 클래스의 주 생성자에 넣는다.


override
 ㄴ 8장에서 다시 언급

require
 ㄴ 전제 조건을 만들 때 사용